//===============Описание регистров памяти обмена. тип: Unsigned Int===================
//
//| номера регистров | номера ячеек массива регистров | содержание регистра | описание|
//
//  № | Share_Mem[№] | содержание | ------------Описание-------------------------------
//  1		0   		R_Quants,				регистр состояния процессов
//  2   	1   		B_ac_TIC,			    Аналоговый сигнал с TIC (обороты ТМН)
//  3   	2   		ac_APG,     			Давление с вакууметра APG
//  4   	3  		 	ac_WRG,    				Давление с вакууметра WRG
//  5   	4   		ac_MFC1,      			Поток газонатекания через РРГ1 
//  6   	5   		ac_MFC2,    			Поток газонатекания через РРГ2
//  7   	6   		ac_CVM,                 Давление с вакууметра CVM
//  8   	7   		ac_7					Не используется
//  9   	8   		ac_8					Не используется
//                                              Резерв
//  14  	13      	com_rx					Регистр-буфер принятых данных через COM-порт
//  16		15			rg_dc		 			Регистр сигналов ДК
//  18		17			err_code				Буфер ошибок 
//          			       					Резерв
//  21  	20  								Состояние цикла записи/чтения (если !=0 то
//												было обращение клиента => обновляем сервер)
//  22  	21  								Номер команды для исполнения
//  23		22									Параметр команды
//  24		23			au_MFC1					Задание потока газонатекания через РРГ1
//  25		24			au_MFC2					Задание потока газонатекания через РРГ2
//  26  	25      	au_Shd_speed            скорость вращения ШД
//  27  	26      	au_Shd_accel            ускорение вращения ШД
//  28		27			rg_du	         		Регистр ДУ
//  29		28			au_servo1               положение сервопривода заслонки
//  30		29			au_servo2               положение сервопривода дросселирования
//------------------------------------------------------------------------------------
//
//===============Содержание процессов в регистре состояния процессов №1===============
//
// номер бита | процесс	--------------------------------------------------------------
//		1		ФВ откачка
//		2		ВВ откачка
//		3		разгон ТМН
//		4		торможение ТМН
//		5		напуск газа через РРГ1
//		6		напуск газа через РРГ2
//		7		продув газовой линейки
//		8		отправка символов через COM-порт 1
//------------------------------------------------------------------------------------
//
//===============Описание команд, записанных в ригистры №22 ==========================
//
// значение регистра 22 | поцедуры обработки команд | --Описание----------------------
//			1		 		vacuum_start()				Запуск процесса откачки
//			2				vacuum_stop()				Запуск процесса остановки откачки
//			3											Процесс напуска газа через РРГ1
//			4				napusk_start()				Процесс постепенного напуска газа через РРГ2
//          5											Открытие/Закрытие клапанов
//          6											Изменение положения серводвигателя заслонки
//          7											Изменение положения серводвигателя дросселирования
//          51											отправка символа через COM-порт 1
//			52-57			otpravka_symvolov() 		Сформировать последовательность команд 
//														для отправки через COM-порт 1 на контроллер ШД
//          52											непрерывное вращение шагового двигателя
//          53				SMC_reset()					остановить ШД
//          54											перемещение ШД по заданной координате
//          55											перемещение ШД на заданное число шагов по часовой
//          56											перемещение ШД на заданное число шагов против часовой
//          57											сканирующее движение ШД
//          100											завершение работы программы
//          10/20										вкл./выкл. автоматической откачки
//          30/40										вкл./выкл. автоматической продувки газовой линейки
//          1000	    	Avarya();					аварийная остановка откачки
//------------------------------------------------------------------------------------
//
//===============Описание параметров команд, записанных в ригистры №23 ===============
//
// значение регистра 22 | значение регистра 23 | ---Описание--------------------------
//			1					1/2					Запуск ФВН/ТМН
//			2					1/2					Останов ФВН/ТМН
//			5					1 - 6				номер клапана
//			6					0 - 4379			устанавливаемое значение в мВ на канал АУ	
//			7					0 - 4379			устанавливаемое значение в мВ на канал АУ
//			51					?					код отправляемого символа в ASCII
//			52					1/2					1 - вращать по часовой 2 - против часовой
//			54					0 - 800				координата в шагах относительно 0 положения
//			55,56				0 - ?				количество шагов
//			57					?					сектор сканирования в градусах								
//------------------------------------------------------------------------------------
//
//===============Содержание ошибок в буфере ошибок №18 ===============================
//
// номер бита | описание ошибки-------------------------------------------------------
//		1		ошибка вакууметра APG (не показывает верные значения)
//		2		давление превышает трбуемое при попытке запуска ТМН
//		3		плохой вакуум (давление WRG возросло выше треуемого во время работы ТМН)
//		4		ошибка иницализации таймера ПЛК	
//		5		ошибка инициализации COM-порта 1							
//------------------------------------------------------------------------------------

//	Используемые сокращения:
//	РРГ - регулятора расхода газа
//	ТМН - турбомолекулярный насос
//	ФВН - форвакуумный насос
//	ФВ - форвакуумный
//	ВВ - высоковакуумный
//	ШД - шаговый двигатель
//	ДК - дискретный контроль
//	ДУ - дискретное управление
//	АК - аналоговый контроль
//	АУ - аналоговое управление
//	ПЛК - программируемый логический контроллер
//	TIC - контроллер управления элементами создания и контроля вакуума

//	Подключение библиотек ПЛК
#include "mod.h"
#include "5510drv.h"
#include "stdlib.h"
#include "math.h"

//Размер памяти обмена сервера - 31 регистр
#define sizeofShareMem	31
#define NULL_MAG_DELTA 319

//===================Инициализация переменных=========================================
unsigned int		// Содержание
Share_Mem[sizeofShareMem],	//память обмена
R_Quants=0,			// регистр состояния процессов
rg_dc,				// регистр ДК
rg_du,				// регистр ДУ
command=0,			// код команды
dop_command=0,		// дополнительный код команды
err_code=0;			// буфер ошибок

//-------------------- номера модульных слотов ПЛК -----------------------------------
unsigned char
slot_au=0,			// номер слота с модулем аналогового управления;
slot_ac=1,			// номер слота с модулем аналогового контроля;
slot_dc=2,			// номер слота с модулем дискретного контроля;
slot_du=3;  		// номер слота с модулем дискретного управления;

//-------------------- номера каналов модуля АК ПЛК ----------------------------------
unsigned int
B_ac_TIC=0,			// сигнал разгон ТМН
B_ac_APG=1,   		// сигнал давление с вакууметра APG
B_ac_WRG=2,			// сигнал давление с вакууметра WRG
B_ac_MFC1=3,		// сигнал поток газонатекания через РРГ1
B_ac_MFC2=4,		// сигнал поток газонатекания через РРГ2
B_ac_CVM=5,     	// сигнал давление с вакууметра CVM

//-------------------- номера каналов модуля АУ ПЛК ----------------------------------
B_au_MFC1=0,    	// сигнал задание потока газонатекания через РРГ1	
B_au_MFC2=1,    	// сигнал задание потока газонатекания через РРГ2
B_au_Servo1=2,  	// сигнал положение серводвигателя заслонки
B_au_Servo2=3,  	// сигнал положение серводвигателя дросселирования

//-------------------- номера каналов модуля ДК ПЛК ----------------------------------
B_dc_Alarm_TIC=0, 	// сигнал ошибка контроллера TIC
				
//-------------------- номера каналов модуля ДУ ПЛК ----------------------------------
B_du_FVN_on=0,  	// сигнал включить ФВН
B_du_TMN_on=1,		// сигнал включить ТМН
B_du_VE_1_on=5,		// сигнал открыть клапан №1
B_du_VE_2_on=6,		// сигнал открыть клапан №2
B_du_VE_3_on=7,		// сигнал открыть клапан №3
B_du_VE_4_on=8,		// сигнал открыть клапан №4
B_du_VE_5_on=9, 	// сигнал открыть клапан №5
B_du_VE_6_on=10,	// сигнал открыть клапан №6
B_du_SMC_reset=12,	// сигнал reset контроллера ШД
			
//-------------------- значения регистров АК -----------------------------------------
ac_APG,				//	Давление с вакууметра APG			
ac_WRG,				//	Давление с вакууметра WRG
ac_CVM,         	//	Давление с вакууметра CVM
ac_MFC1,			//	поток газонатекания через РРГ1
ac_MFC2,			//	поток газонатекания через РРГ2
					
//-------------------- значения регистров АУ -----------------------------------------
au_MFC1=0,			// задание потока газонатекания через РРГ1
au_MFC2=0,			// задание потока газонатекания через РРГ2
au_prev_MFC2=0,		// предыдущее значение au_MFC2 
au_Shd_speed=0,		// скорость вращения ШД
au_Shd_accel=0,		// ускорение вращения ШД
au_Servo1=0,		// положение серводвигателя заслонки
au_Servo2=0;		// положение серводвигателя дросселирования

//==========Маски каналов дискретного управления======================================
//----------используются для побитовых операций с регистрами--------------------------
unsigned int
mask_on[16]=
{0x1,		//канал 0	0000 0000 0000 0001
 0x2,		//канал 1	0000 0000 0000 0010
 0x4,		//канал 2	0000 0000 0000 0100
 0x8,		//канал 3	0000 0000 0000 1000
 0x10,		//канал 4	0000 0000 0001 0000
 0x20,		//канал 5	0000 0000 0010 0000
 0x40,		//канал 6	0000 0000 0100 0000
 0x80,		//канал 7	0000 0000 1000 0000
 0x100,		//канал 8	0000 0001 0000 0000
 0x200,		//канал 9	0000 0010 0000 0000
 0x400,	    //канал 10	0000 0100 0000 0000
 0x800,	    //канал 11	0000 1000 0000 0000
 0x1000,	//канал 12	0001 0000 0000 0000
 0x2000,	//канал 13	0010 0000 0000 0000
 0x4000,	//канал 14	0100 0000 0000 0000
 0x8000,	//канал 15	1000 0000 0000 0000
 },
 mask_off[16]=
{0xfffe,	//канал 0	1111 1111 1111 1110
 0xfffd,	//канал 1	1111 1111 1111 1101
 0xfffb,	//канал 2	1111 1111 1111 1011
 0xfff7,	//канал 3	1111 1111 1111 0111
 0xffef,	//канал 4	1111 1111 1110 1111
 0xffdf,	//канал 5	1111 1111 1101 1111
 0xffbf,	//канал 6	1111 1111 1011 1111
 0xff7f,	//канал 7	1111 1111 0111 1111
 0xfeff,	//канал 8	1111 1110 1111 1111
 0xfdff,	//канал 9 	1111 1101 1111 1111
 0xfbff,	//канал 10	1111 1011 1111 1111
 0xf7ff,	//канал 11	1111 0111 1111 1111
 0xefff,	//канал 12	1110 1111 1111 1111
 0xdfff,	//канал 13	1101 1111 1111 1111
 0xbfff,	//канал 14	1011 1111 1111 1111
 0x7fff,	//канал 15	0111 1111 1111 1111
 };
					
//------------------- вспомагательные переменные -------------------------------------
unsigned int					
vsp_array[8],		//вспомагательный массив для работы с модулями АУ и АК
v_ac,  	  			//вспомогательная переменная для состояния каналов АК
v_mask,   			//вспомогательная маска
ac_contr;			//для аналогового контроля
unsigned long
vsp_long;			//вспомогательное длинное

//------------------- константы вакуумной откачки ------------------------------------
unsigned int		
//APG_st_TMN=1600, 	//Давление APG требуемое для запуска TMN в дискретах
WRG_st_TMN=2720,    //Давление WRG требуемое для запуска TMN в дискретах
Min_TMN_Time=300,   //Минимальное время ФВ откачки перед запуском ТМН
P_WRG_B=2735;		//Давление WRG после откачки,
					//свидетельствующее о плохом вакууме в камере в дискретах

//----------------------- флаги 1/0	--------------------------------------------------
unsigned int 			//флаги 1/0
auto_vacuum_start=0,	//автоматически переходить на ВВ откачку?
auto_produv_start=0,    //автоматически продувать газовую линию?
produv_state=0,         //продув газовой линии завершен?
SHd_state=0;       		//положение ШД определено?

//------------------- счетчики -------------------------------------------------------
unsigned int
n1vacuum=0,     	//счетчик времени 1 этапа откачки
n1produv=0;			//счетчик времени продува газовой линии
unsigned char
n_vacuum=1;			//текущий этап откачки

//------------------- прочее ---------------------------------------------------------
unsigned int
smb_to_send=0,  	//кол-во символов, которые надо отправить через COM-порт 1
SHd_position=0, 	//текущая координата ШД в шагах относительно 0 положения
Shd_enable_flag =0, //флаг включения тока обмоток двигателя.
produv_time=300;	//время продува газовой линии

//------------------- переменные для работы с COM-портом -----------------------------
char
text_to_send[100],	//буфер символов для отправки
str[5];				//буфер для посимвольной записи чисел

//---------------------------------------- шаблоны последовательностей команд --------
//---------------------------------------- для отправки через COM-порт 1 ------------- 
char
start_left[13]="<LM>DL>SS0>AL",			
start_right[13]="<LM>DR>SS0>AL",
step_left[15]="<LM>DL>SD100>MV",
step_right[15]="<LM>DR>SD100>MV",
move_text[7]=">MV>FS>",
start_text[4]=">FS>",
speed_text[3]=">SD",
mv_text[3]=">MV",
acc_text[4]=">AL-",
scan_init[13]=">RS>LL>SS0>AL",
scan_speed[7]=">SD0>MV",
scan_start[15]=">RS>JP5>JP2>FS>",
home_text[18]="<LM>DR>SD100>HM>MV";

//---------------------------------------- переменные для пультовой петли ------------
enum {ACTIV, PASSIV} dispetcher;		// диспетчер задач (вкл./выкл.)
enum {PRIORY, DONUT} queue;				// последовательность обработки задач:
										// (по приоритету / последовательно)
										

//---------------------------------------- специальный тип "процесс,квант"------------
typedef struct {
	int tm;						//индекс прикрепленного таймера
	enum {STOP, START} stt;		//состояние процесса:STOP-остановлен,
				}				//START - в очереди на исполнение
typ_sq;          				

//-------------------- кванты процессов, обслуживаемых в диспетчере задач ------------
typ_sq
q_vacuum_start,		// процесс запуска вакуумной откачки
q_vacuum_stop,	    // процесс останова вакуумной откачки
q_napusk_start,		// процесс постепенного увеличения потока газонатекания
					// через РРГ до заданного значения
q_produv_start,		// процесс продува газовой линии
q_com_tx,			// процесс отправки символов через COM-порт
q_SMC_reset;		// процесс подачи и снятия сигнала сброс на контроллер ШД

//=============== Процедуры и функции для работы с каналами модулей ПЛК ==================================

//--------------------------------Аналоговый контроль-----------------------------------------------------
unsigned int a_cntrl(int slot_ac, int n_kanal)	//вводим номер слота и номер канала
{
	Get5017H_P1(slot_ac,n_kanal,&ac_contr);		//процедура считывания напряжения ПЛК 
	ac_contr=ac_contr&0x0FFF;					//модуль передает значение в 12 битах
	return ac_contr;							//возвращаем значение в дискретах
}
//--------------------------------Включить канал ДУ-------------------------------------------------------
void du_on(int slot, int n_kanal)				//вводим номер слота и номер канала
{
	Get5050(slot,0,AWord,&v_mask);				//считываем текущее состояние каналов в переменную v_mask
	v_mask=(v_mask)|(mask_on[n_kanal]);			//изменяем значение бита переменной на 1 (высокий уровень)
												//(номер бита равен номеру переключаемого канала)
	Set5050(&v_mask,slot,0,AWord);  			//процедура установки состояния каналов ПЛК
}
//--------------------------------Выключить канал ДУ------------------------------------------------------
void du_off(int slot, int n_kanal)				//вводим номер слота и номер канала
{
	Get5050(slot,0,AWord,&v_mask);				//считываем текущее состояние каналов в переменную v_mask
	v_mask=(v_mask)&(mask_off[n_kanal]);		//изменяем значение бита переменной на 0 (низкий уровень)
												//(номер бита равен номеру переключаемого канала)
	Set5050(&v_mask,slot,0,AWord);  			//процедура установки состояния каналов ПЛК
}
//--------------------------------Инвертировать канал ДУ--------------------------------------------------
void du_inv(int slot, int n_kanal)				//вводим номер слота и номер канала
{
	Get5050(slot,0,AWord,&v_mask);				//считываем текущее состояние каналов в переменную v_mask
	if ((v_mask&mask_on[n_kanal])==0)			//если состояние бита = 0,
		v_mask=(v_mask)|(mask_on[n_kanal]);		//то меняем на 1
	else										//(номер бита равен номеру переключаемого канала)
		v_mask=(v_mask)&(mask_off[n_kanal]);	//иначе меняем на 0
	   
	Set5050(&v_mask,slot,0,AWord);				//процедура установки состояния каналов ПЛК
}
//--------------------------------Проверить канал ДК------------------------------------------------------
int dc(int slot, int n_kanal)					//вводим номер слота и номер канала
{								
	Get5050(slot,0,AWord,&v_mask);				//считываем текущее состояние каналов в переменную v_mask
	return v_mask&mask_on[n_kanal];				//возвращаем 0, если канал замкнут или в низком уровне
}												//и не 0, если разомкнут или в высоком уровне

//=======================Вспомагательные функции и процедуры для работы с COM-портом======================

//--------------------------------Определить количесво знаков в числе-------------------------------------
int smb_counter(unsigned int chislo)				//вводим число
{
	int kolvo=1;									//счетчик количества знаков
	while (chislo=chislo/10)   						//уменьшаем разрядность числа на 1 до тех пор,
	kolvo++;										//пока оно не станет равно 0
	return kolvo;									//возвращаем количество знаков
}
//--------------------------------Записать в буфер символов для отправки по COM-порту числовое значение---
int smb_writer(int str_length, unsigned int chislo)	// вводим текущее кол-во символов в буфере
{													// и число для записи
	int i, smb_count;									
    smb_count=smb_counter(chislo); 					// Определяем кол-во символов в числе
	itoa(chislo,str,10);        					// переводим число в символы в строку str
	for (i=0;i<smb_count;i++)							
	text_to_send[str_length+i]=str[i];				// посимвольно записываем число в буфер символов
	return (str_length+smb_count);					// возвращаем текущую длину буфера символов
}
//--------------------------------Записать в буфер символов для отправки по COM-порту шаблон символов-----
void pattern_writer(int str_length, int smb_count,char pattern[])
{
	int i;											
	for (i=0;i<smb_count;i++)						
		text_to_send[str_length+i]=pattern[i];		// посимвольно переписываем шаблон в буфер символов
}

//-------------------------------- Процедура обработки команды #1000 аварийная остановка откачки ---------
void Avarya(void)
{
	vsp_long=0;
	R_Quants=R_Quants & mask_off[5];					//записываем 0 в 5 бит регистра состояния процессов (напуск через РРГ1)	
	Set5024(&vsp_long,slot_au,B_au_MFC1);				//устанавливаем поток РРГ1 = 0
	R_Quants=R_Quants & mask_off[6];					//записываем 0 в 6 бит регистра состояния процессов (напуск через РРГ2)
	Set5024(&vsp_long,slot_au,B_au_MFC2);				//устанавливаем поток РРГ2 = 0
	
	du_off(slot_du,B_du_TMN_on);						//выключаем ТМН
	du_on(slot_du,B_du_FVN_on);							//включаем ФВН
		
	q_vacuum_stop.stt=START;							//активируем процесс остановки откачки
	q_vacuum_start.stt=STOP;							//дективируем процесс откачки
	q_produv_start.stt=STOP;							//деактивируем процесс продува
	R_Quants=R_Quants & mask_off[2];					//записываем 0 в 2 бит регистра состояния процессов (ВВ откачка)
	R_Quants=R_Quants | mask_on[4];						//записываем 1 в 4 бит регистра состояния процессов (торможение ТМН)
	R_Quants=R_Quants & mask_off[3];					//записываем 0 в 3 бит регистра состояния процессов (разгон ТМН)
	R_Quants=R_Quants & mask_off[7];					//записываем 0 в 7 бит регистра состояния процессов (продув)
	auto_vacuum_start=1;								//принудительно автоматизируем процесс откачки

	Get5050(slot_du,0,AWord,&v_mask);					//Считываем состояние модуля ДУ
	v_mask=(v_mask)&(0xF81F);							//переводим каналы 5-10 в низкий уровень: 1111 1000 0001 1111
	Set5050(&v_mask,slot_du,0,AWord);					//закрываем клапаны газовой линии
}

//=============================== Процедура обновления сервера ===========================================

void server_update(void)
{
	int i, strlen;
	double accel_distance;

//------------------------------- Считываем показания модулей ПЛК ----------------------------------------	
	for (i=0;i<8;i++)									
		{												
		Get5017H_P1(slot_ac,i,&ac_contr);				//Считываем показания модуля АК
		vsp_array[i]=ac_contr&0x0FFF;					//во вспомогательную переменную
		}

	Get5050(slot_dc,0,AWord,&v_mask);					//Считываем показания модуля ДК
	rg_dc=v_mask;										//в регистр ДК
	
	Get5050(slot_du,0,AWord,&v_mask);					//Считываем состояние модуля ДУ
	rg_du=v_mask;										//в регистр ДУ

//------------------------------- Обновляем/считываем память обмена --------------------------------------	
	disable();											//Запрещаем прерывания, чтобы не менялась память обмена
	Share_Mem[0]=R_Quants;								//обновляем регистр состояния процессов
	Share_Mem[1]=vsp_array[0]; 							//обновляем показания АК
	Share_Mem[2]=vsp_array[1];
	Share_Mem[3]=vsp_array[2];
	Share_Mem[4]=vsp_array[3];
	Share_Mem[5]=vsp_array[4];
	Share_Mem[6]=vsp_array[5];
	Share_Mem[7]=vsp_array[6];
	Share_Mem[8]=vsp_array[7];
	ac_APG=Share_Mem[2];								//показания датчиков давления заносим в переменные
	ac_WRG=Share_Mem[3];								//для дальнейшей работы с ними
	Share_Mem[13]=com_rx();								//записываем очередной принятый символ через COM-порт
	Share_Mem[15]=rg_dc;								//обновляем показания ДК
	Share_Mem[17]=err_code;								//обновляем значение регистра ошибок
	Share_Mem[20]=0;									//обнуляем регистр состояния цикла записи/чтения
	command=Share_Mem[21];								//считываем регистр, содержащий код команды клиента
	dop_command=Share_Mem[22];							//считываем регистр, содержащий параметр команды
	Share_Mem[21]=0;									//обнуляем регистр (команда считана)
	Share_Mem[22]=0;									//обнуляем регистр (параметр команды считан)
	au_MFC1=Share_Mem[23];								//считываем какой поток использовать для задания РРГ1
	au_MFC2=Share_Mem[24];								//считываем какой поток использовать для задания РРГ2
	au_Shd_speed=Share_Mem[25];           				//считываем какую скорость вращения использовать для ШД
	au_Shd_accel=Share_Mem[26];           				//считываем какое ускорение вращения использовать для ШД
	Share_Mem[27]=rg_du;     							//обновляем состояние ДУ
	Share_Mem[28]=au_Servo1;         					//обновляем в каком положении находится сервопривод заслонки
	Share_Mem[29]=au_Servo2;          					//обновляем в каком положении находится сервопривод дросселирования
	enable();											//Разрешаем прерывания
	
//------------------------------- Исполнение команд клиента ----------------------------------------------	
	if (command!=0)										//если была получена команда от клиента
	{
	switch (command)
	{
//------------------------------- Команда №1 запустить откачку -------------------------------------------
	case 1:
	if (dop_command==1)									//клиент просит запустить ФВН
		{
		q_vacuum_start.stt=START;						//активируем процесс откачки
		R_Quants=R_Quants | mask_on[1]; 				//записываем 1 в 1 бит регистра состояния процессов (ФВ откачка)
		n1vacuum=0;										//обнуляем счетчик времени ФВ откачки
		du_on(slot_du,B_du_FVN_on);						//запускаем ФВН
		if ((ac_APG<550)||(ac_APG>4000)) 				//если показания датчика APG не в этом диапазоне, то
			err_code=err_code | mask_on[1]; 			//записываем 1 в 1 бит регистра ошибок "ошибка вакууметра APG"
		else err_code=err_code & mask_off[1]; 			//иначе записываем 0 в 1 бит регистра ошибок
		}
		
	if (dop_command==2)									//клиент просит запустит ТМН				
		{
		if ((n1vacuum>Min_TMN_Time)&&(ac_WRG<WRG_st_TMN))	//если минимальное время ФВ откачки, давление WRG
		if (q_produv_start.stt==STOP)						//Достигло давления запуска ТМН и процесс продува
															//газовой линии не активен
//		if (ac_APG<APG_st_TMN)     							//если давление APG достигло давления старта ТМН
			{
			n_vacuum=2;    								//текущий этап откачки - 2
			du_on(slot_du,B_du_TMN_on);  				//запускаем ТМН
			q_vacuum_stop.stt=STOP;						//деактивируем процесс останова откачки
			q_vacuum_start.stt=START;					//активируем процесс откачки
			R_Quants=R_Quants | mask_on[2]; 			//записываем 1 в 2 бит регистра состояния процессов (ВВ откачка)
			R_Quants=R_Quants | mask_on[3]; 			//записываем 1 в 3 бит регистра состояния процессов (разгон ТМН)
			R_Quants=R_Quants & mask_off[4];			//записываем 0 в 4 бит регистра состояния процессов (торможение ТМН)
			err_code=err_code & mask_off[2]; 			//записываем 0 в 2 бит регистра ошибок 
			}
		else
			err_code=err_code | mask_on[2]; 			//иначе записываем 1 в 2 бит регистра ошибок "давление выше требуемого"
		}
	break;

//------------------------------- Команда №2 остановить откачку ------------------------------------------
	case 2:		
	if (dop_command==1)									//клиент просит выключить ФВН
		{
		if ((R_Quants & mask_on[2])==0)					//если 2 бит регистра состояния процессов = 0 (ВВ откачка)
		if ((R_Quants & mask_on[4])==0)					//если 4 бит регистра состояния процессов = 0 (торможение ТМН)
			{
			du_off(slot_du,B_du_FVN_on);				//выключаем ФВН
			q_vacuum_stop.stt=STOP;						//деактивируем процесс останова откачки
			R_Quants=R_Quants & mask_off[1];			//записываем 0 в 1 бит регистра состояния процессов (ФВ откачка)
			du_off(slot_du,B_du_VE_2_on);				//закрываем клапаны 2,3,5,6
			du_off(slot_du,B_du_VE_3_on);
			du_off(slot_du,B_du_VE_5_on);
			du_off(slot_du,B_du_VE_6_on);

			if (q_produv_start.stt==START)	 			//если был запущен процесс продува газовой линии
				{
				q_produv_start.stt=STOP;				//еактивируем процесс продува газовой линии
				R_Quants=R_Quants & mask_off[7];		//записываем 0 в 1 бит регистра состояния процессов (продув)
				R_Quants=R_Quants & mask_off[5]; 		//записываем 0 в 5 бит регистра состояния процессов (напуск через РРГ1) 
				vsp_long=0;                				
				Set5024(&vsp_long,slot_au,B_au_MFC1);	//устанавливаем поток РРГ1 = 0
				R_Quants=R_Quants & mask_off[6]; 		//записываем 0 в 6 бит регистра состояния процессов (напуск через РРГ2) 
				vsp_long=0;               
				Set5024(&vsp_long,slot_au,B_au_MFC2);	//устанавливаем поток РРГ2 = 0
				}
			}
		}
		
	if (dop_command==2)									//клиент просит выключить ТМН
		{
		du_off(slot_du,B_du_TMN_on);					//выключаем ТМН
		q_vacuum_stop.stt=START;						//активируем процесс останова откачки
		q_vacuum_start.stt=STOP;						//деактивируем процесс откачки
		R_Quants=R_Quants & mask_off[2];				//записываем 0 в 2 бит регистра состояния процессов (ВВ откачка)
		R_Quants=R_Quants & mask_off[3];				//записываем 0 в 3 бит регистра состояния процессов (разон ТМН)
		R_Quants=R_Quants | mask_on[4];					//записываем 1 в 4 бит регистра состояния процессов (торможение ТМН)
		du_off(slot_du,B_du_VE_2_on);					//закрываем клапаны 2,3,5,6
		du_off(slot_du,B_du_VE_3_on);
		du_off(slot_du,B_du_VE_5_on);
		du_off(slot_du,B_du_VE_6_on);
		}
	break;
	
//------------------------------- Команда №3 напускать газ через РРГ1 ------------------------------------
	case 3:		
	if (au_MFC1>0)										//если задание потока болше нуля
		{
		R_Quants=R_Quants | mask_on[5]; 				//записываем 1 в 5 бит регистра состояния процессов (напуск через РРГ1)
		vsp_long=au_MFC1;               				
		Set5024(&vsp_long,slot_au,B_au_MFC1);			//задаем потока РРГ1 = au_MFC1
		}
	else												//иначе
		{
		R_Quants=R_Quants & mask_off[5];				//записываем 0 в 5 бит регистра состояния процессов (напуск через РРГ1)
		vsp_long=au_MFC1;
		Set5024(&vsp_long,slot_au,B_au_MFC1);			//устанавливаем поток РРГ1 = 0
		}
	break;
	
//------------------------------- Команда №4 напускать газ через РРГ2 ------------------------------------
	case 4:
	if (au_MFC2>0)										//если задание потока болше нуля
		{
		R_Quants=R_Quants | mask_on[6]; 				//записываем 1 в 6 бит регистра состояния процессов (напуск через РРГ2)
		q_napusk_start.stt=START;						//активируем процесс постепенного увеличения потока до заданного значения
		}
	else												//иначе
		{												
		R_Quants=R_Quants & mask_off[6];				//записываем 0 в 6 бит регистра состояния процессов (напуск через РРГ2)
		vsp_long=au_MFC2;
		Set5024(&vsp_long,slot_au,B_au_MFC2);			//устанавливаем поток РРГ2 = 0
		au_prev_MFC2=0;									//обновляем переменную "предыдущее значение потока" = 0
		}
	break;
	
//------------------------------- Команда №5 открыть/закрыть клапан --------------------------------------
	case 5:
	du_inv(slot_du,dop_command+4);						//переключить состояние клапана (№ = dop_command)
	break;
	
//------------------------------- Команда №6 изменить положение сервопривода заслонки --------------------
	case 6:
	au_Servo1=dop_command;								//обновляем переменную положения сервопривода
	vsp_long=au_Servo1;
	Set5024(&vsp_long,slot_au,B_au_Servo1);				//задаем положение сервопривода = au_Servo1
	break;
	
//------------------------------- Команда №7 изменить положение сервопривода дросселирования -------------
    case 7:
	au_Servo2=dop_command;								//обновляем переменную положения сервопривода
	vsp_long=au_Servo2;
	Set5024(&vsp_long,slot_au,B_au_Servo2);				//задаем положение сервопривода = au_Servo2
	break;
	
//------------------------------- Команды №10,20,30,40 вкл./выкл. автоматизации --------------------------
	case 10:
	auto_vacuum_start=1;								//автоматически переходить на ВВ откачку
	break;
	
	case 20:
	auto_vacuum_start=0;								//НЕ переходить автоматически на ВВ откачку
	break;
	
	case 30:
	auto_produv_start=1;								//автоматически продувать газовую линию
	produv_time=dop_command;
	break;												//во время ФВ откачки
	
	case 40:
	auto_produv_start=0;								//НЕ продувать автоматически газовую линию
	break;												//во время ФВ откачки

//------------------------------- Команда №51 отправить символ через COM-порт 1 --------------------------	
	case 51:
	com_tx(dop_command);								//отправляем символ, код ASCII которого = dop_command
	break;
	
//------------------------------- Команда №52 вращать ШД с заданной скоростью ----------------------------	
	case 52:
	if ((R_Quants & mask_on[8])==0)						//если не активен процес отправки символов через COM-порт
		{
		R_Quants=R_Quants | mask_on[8];					//записываем 1 в 8 бит регистра состояния процессов (отправка символов)
		q_com_tx.stt=START;								//активируем процесс отправки символов через COM-порт
		if (dop_command==1)								//если клиент запрашивает поворот по часовой стрелке
			pattern_writer(0,13,start_right);			//записываем в буфер 13 символов <LM>DR>SS0>AL с нулевого
		if (dop_command==2)								//если клиент запрашивает поворот против часовой стрелки
			pattern_writer(0,13,start_left);			//записываем в буфер 13 символов <LM>DL>SS0>AL с нулевого
		strlen=smb_writer(13,au_Shd_accel);				//добавляем в буфер значение ускорения, возвращаем текущую длину буфера
		pattern_writer(strlen,3,speed_text);			//добавляем >SD
		strlen=smb_writer(3+strlen,au_Shd_speed);		//добавляем значение скорости
		pattern_writer(strlen,7,move_text);				//добавляем >MV>FS>
		smb_to_send=7+strlen;							//записываем в переменную итоговую длину буфера
		SHd_state=FALSE;								//записываем, что положение ШД не определено
		}		
	break;

//------------------------------- Команда №53 остановить ШД ----------------------------------------------
	case 53:
	if ((R_Quants & mask_on[8])==0)						//если не активен процес отправки символов через COM-порт
		{
		du_on(slot_du,B_du_SMC_reset);					//подаем сигнал на вход reset контроллера ШД
		q_SMC_reset.stt=START;							//активируем процесс переключения сигнала сброс контроллера ШД
		Timer_Reset(q_SMC_reset.tm);					//перезапускаем таймер процесса
		SHd_state=FALSE;								//записываем, что положение ШД не определено
		}
	break;
	
//------------------------------- Команда №54 переместить ШД до заданной координаты ----------------------	
	case 54:
	if ((R_Quants & mask_on[8])==0)						//если не активен процес отправки символов через COM-порт
		{
		R_Quants=R_Quants | mask_on[8];					//записываем 1 в 8 бит регистра состояния процессов (отправка символов)
		q_com_tx.stt=START;								//активируем процесс отправки символов через COM-порт
		if (SHd_state==false)							//если не известно текущее положение ШД
			{
			pattern_writer(0,18,home_text);				//записываем в буфер 18 символов <LM>DR>SD100>HM>MV с нулевого
			strlen=smb_writer(18,dop_command + NULL_MAG_DELTA); //добавляем число шагов (число шагов = координате)
			pattern_writer(strlen,4,start_text);		//добавляем >FS>
			smb_to_send=4+strlen;						//записываем в переменную итоговую длину буфера
			SHd_position=dop_command;					//записываем текущую координату ШД
			SHd_state=TRUE;								//записываем, что положение ШД определено
			}
		else											//если известно текущее положение ШД
			{
			pattern_writer(0,15,step_right);			//записываем в буфер 15 символов <LM>DR>SD100>MV с нулевого
			dop_command=(dop_command+800-SHd_position)%800;	//рассчитываем сколько шагов нужно сделать до заданной координаты
			strlen=smb_writer(15,dop_command);          //добавляем число шагов
			pattern_writer(strlen,4,start_text);		//добавляем >FS>
			smb_to_send=4+strlen;						//записываем в переменную итоговую длину буфера
			SHd_position=(SHd_position+dop_command)%800;	//записываем текущую координату ШД
			}
		}
	break;
	
//------------------------------- Команда №55 переместить ШД по часовой стрелке --------------------------
	case 55:
	if ((R_Quants & mask_on[8])==0)						//если не активен процес отправки символов через COM-порт
		{
		R_Quants=R_Quants | mask_on[8];					//записываем 1 в 8 бит регистра состояния процессов (отправка символов)
		q_com_tx.stt=START;								//активируем процесс отправки символов через COM-порт
		pattern_writer(0,15,step_right);				//записываем в буфер 15 символов <LM>DR>SD100>MV с нулевого
		strlen=smb_writer(15,dop_command);          	//добавляем число шагов
		pattern_writer(strlen,4,start_text);			//добавляем >FS>
		smb_to_send=4+strlen;							//записываем в переменную итоговую длину буфера
		SHd_position=(SHd_position+dop_command)%800;	//записываем текущую координату ШД
		}
	break;
	
//------------------------------- Команда №56 переместить ШД против часовой стрелки ----------------------	
	case 56:
	if ((R_Quants & mask_on[8])==0)						//если не активен процес отправки символов через COM-порт
		{
		R_Quants=R_Quants | mask_on[8];					//записываем 1 в 8 бит регистра состояния процессов (отправка символов)
		q_com_tx.stt=START;								//активируем процесс отправки символов через COM-порт
		pattern_writer(0,15,step_left);					//записываем в буфер 15 символов <LM>DL>SD100>MV с нулевого
		strlen=smb_writer(15,dop_command);          	//добавляем число шагов
		pattern_writer(strlen,4,start_text);			//добавляем >FS>
		smb_to_send=4+strlen;							//записываем в переменную итоговую длину буфера
		SHd_position=(SHd_position+800-dop_command)%800;	//записываем текущую координату ШД
		}
	break;
	
//------------------------------- Команда №57 задать сканирующее движение ШД -----------------------------
	case 57:
	if ((R_Quants & mask_on[8])==0)						//если не активен процес отправки символов через COM-порт
		{
		R_Quants=R_Quants | mask_on[8];					//записываем 1 в 8 бит регистра состояния процессов (отправка символов)
		q_com_tx.stt=START;								//активируем процесс отправки символов через COM-порт
		pattern_writer(0,15,step_left);					//записываем в буфер 15 символов <LM>DL>SD100>MV с нулевого
		strlen=smb_writer(15,dop_command/2);			//добавляем число шагов равное половине длины дуги
		pattern_writer(strlen,13,scan_init);			//добавляем >RS>LL>SS0>AL
	    strlen=smb_writer(13+strlen,au_Shd_accel);		//добавляем значение ускорения при разгоне
		pattern_writer(strlen,3,speed_text);				//добавляем >SD
	    strlen=smb_writer(3+strlen,au_Shd_speed);		//добавляем значение скорости сканирования
		pattern_writer(strlen,3,mv_text);				//добавляем >MV
	    accel_distance=pow(au_Shd_speed,2)/(2*au_Shd_accel);	//рассчитываем длину дуги ускорения
	    strlen=smb_writer(3+strlen,((dop_command/2)*2)-ceil(accel_distance));
																//добавляем перемещение до начала торможения
		pattern_writer(strlen,4,acc_text);				//добавляем >AL-
	    strlen=smb_writer(4+strlen,au_Shd_accel);		//добавляем значение ускорения при торможении
		pattern_writer(strlen,7,scan_speed);			//добавляем >SD0>MV
		strlen=smb_writer(7+strlen,ceil(accel_distance));	//добавляем длину дуги торможения
		pattern_writer(strlen,15,scan_start);			//добавляем >RS>JP5>JP2>FS>
	    smb_to_send=15+strlen;							//записываем в переменную итоговую длину буфера
		SHd_state=FALSE;								//записываем, что положение ШД не определено
		}
	break;
	
 //------------------------------- Команда №100 завершение работы программы ------------------------------  	
	case 100:
	dispetcher=PASSIV;									//останавливаем цикличность диспетчера задач
	break;
	
 //------------------------------- Команда №1000 аварийная остановка откачки -----------------------------	
	case 1000:
	Avarya();											//выполняем процедуру Avarya
	break;
	}													//Конец дешифровки команд
	}
}

//================================ Процедуры обслуживания процессов ======================================

//-------------------------------- Процедура процесса откачки --------------------------------------------
void vacuum_start(void)
{
	switch (n_vacuum)										//процесс разделен на 3 этапа:
	{
	case 1:													//этап 1: ФВ откачка
		n1vacuum=n1vacuum+1;								//считаем время работы ФВ насоса
															//проверка запуска продува 
		if ((n1vacuum>120)&&(auto_produv_start==1))			//если прошло 120с и запуск продува автоматизирован
		if ((q_produv_start.stt==STOP)&&(produv_state==0))	//при этом продув еще не запущен и не был завершен
			{
			n1produv=0;										//обнуляем время продува
			q_produv_start.stt=START;						//активируем процесс продува газовой линии
			R_Quants=R_Quants | mask_on[7];					//записываем 1 в 7 бит регистра состояния процессов (продув)
			du_on(slot_du,B_du_VE_2_on);					//открываем клапаны 2,3,5,6 газовой линии
			du_on(slot_du,B_du_VE_3_on);
			du_on(slot_du,B_du_VE_5_on);
			du_on(slot_du,B_du_VE_6_on);
			R_Quants=R_Quants | mask_on[5];					//записываем 1 в 5 бит регистра состояния процессов (напуск через РРГ1)
			vsp_long=5000;
			Set5024(&vsp_long,slot_au,B_au_MFC1);			//задаем потока РРГ1 = 5000 дискрет
			R_Quants=R_Quants | mask_on[6];					//записываем 1 в 6 бит регистра состояния процессов (напуск через РРГ2)
			vsp_long=5000;
			Set5024(&vsp_long,slot_au,B_au_MFC2);			//задаем потока РРГ2 = 5000 дискрет
			}
															//принудительное открытие клапанов для откачки газовой линии
		if ((n1vacuum==120)&&(auto_vacuum_start==1)&&(auto_produv_start==0))
			{												//если прошло 120с и откачка автоматизирована
			du_on(slot_du,B_du_VE_2_on);					//то открываем клапаны 2,3,5,6
			du_on(slot_du,B_du_VE_3_on);
			du_on(slot_du,B_du_VE_5_on);
			du_on(slot_du,B_du_VE_6_on);
			}
															//проверка запуска ТМН
		if ((n1vacuum>Min_TMN_Time)&&(auto_vacuum_start==1))	//если прошло минимальное время для запуска ТМН
		if ((q_produv_start.stt==STOP)&&(ac_WRG<WRG_st_TMN))	// и откачка автоматизирована, при этом процесс продува не активен
			{													// и давление достоточно низкое для запуска ТМН
			n_vacuum=2;    									//инициируем переход на 2 этап
			du_on(slot_du,B_du_TMN_on);						//запускаем ТМН
			R_Quants=R_Quants | mask_on[2];					//записываем 1 в 2 бит регистра состояния процессов (ВВ откачка)
			R_Quants=R_Quants | mask_on[3];					//записываем 1 в 3 бит регистра состояния процессов (разгон ТМН)
			R_Quants=R_Quants & mask_off[4];				//записываем 0 в 4 бит регистра состояния процессов (торможение ТМН)
			}
	break;

	case 2:													//этап 2: разгон ТМН
		if ((a_cntrl(slot_ac,B_ac_TIC)>3600)&&(a_cntrl(slot_ac,B_ac_TIC)<3700))
			{												//если скорость вращения турбин 100%
			R_Quants=R_Quants & mask_off[3];				//записываем 0 в 3 бит регистра состояния процессов (разгон ТМН)
			n_vacuum=3;										//инициируем переход на 3 этап
			}
	break;
	
	case 3:													//этап 3: слежение за вакуумом
		if (ac_WRG>P_WRG_B)									//если давление опустилось ниже фиксированной отметки
			err_code=err_code | mask_on[3];					//записываем 1 в 3 бит регистра ошибок "Плохой вакуум"
		else err_code=err_code & mask_off[3];				//иначе записываем 0 в 3 бит регстра ошибок
	break;
	}
}

//-------------------------------- Процедура процесса остановки откачки ----------------------------------
void vacuum_stop(void)
{
	switch (n_vacuum)										//в зависимости от того, на каком этапе откачки находимся
	{
	case 3:													//если на 3 этапе
		n_vacuum=2;											//переходим на 2 этап
	break;
	
	case 2:													//если на 2 этапе: торможение ТМН
		if ((a_cntrl(slot_ac,B_ac_TIC)<10)||(a_cntrl(slot_ac,B_ac_TIC)>4000))
			{												//если скорость вращения турбин = 0%
			n_vacuum=1;										//инициируем переход на 1 этап
			R_Quants=R_Quants & mask_off[4];				//записываем 0 в 4 бит регистра состояния процессов (торможение ТМН)		
			}
	break;
	
	case 1:													//если на 1 этапе: ФВ откачка
		if (auto_vacuum_start==1)							//если процесс откачки автоматизирован
			{
			du_off(slot_du,B_du_FVN_on);					//выключаем ФВН
			q_vacuum_stop.stt=STOP;							//деактивируем процесс остановки откачки
			R_Quants=R_Quants & mask_off[1];				//записываем 0 в 1 бит регистра состояния процессов (ФВ откачка)
			}
	break;
	}
}
//-------------------------------- Процедура процесса продува газовой линии ------------------------------
void produv_start(void)
{
	n1produv=n1produv+1;									//считаем время продува 
	if (n1produv>produv_time)										//если прошло 5 мин
		{
		q_produv_start.stt=STOP;							//деактивируем процесс продува							
		R_Quants=R_Quants & mask_off[7];					//записываем 0 в 7 бит регистра состояния процессов (продув)
		R_Quants=R_Quants & mask_off[5];					//записываем 0 в 5 бит регистра состояния процессов (напуск через РРГ1)
		vsp_long=0;
		Set5024(&vsp_long,slot_au,B_au_MFC1);				//устанавливаем поток РРГ1 = 0
		R_Quants=R_Quants & mask_off[6];					//записываем 0 в 6 бит регистра состояния процессов (напуск через РРГ2)
		vsp_long=0;
		Set5024(&vsp_long,slot_au,B_au_MFC2);				//устанавливаем поток РРГ2 = 0
		produv_state=1;										//делаем отметку что продув завершен
		}
}
//-------------------------------- Процедура процесса постепенного увеличения потока через РРГ до заданного --------
void napusk_start(void)
{
	if (au_prev_MFC2>au_MFC2)								//если предыдущее значение было выше текущего задания 
		{
		vsp_long=au_MFC2;									//то сразу выставляем требуемого значение
		Set5024(&vsp_long,slot_au,B_au_MFC2);				//устанавливаем поток РРГ2 = au_MFC2
		au_prev_MFC2=au_MFC2;								//обновляем переменную "предыдущее значение потока"
		q_napusk_start.stt=STOP;							//деактивируем процесс
		}
	else
		{
		if ((au_MFC2-au_prev_MFC2)<=200)					//если нужно увеличить поток менее чем на 200 дискрет
			{
			vsp_long=au_MFC2;								//то сразу выставляем требуемого значение
			Set5024(&vsp_long,slot_au,B_au_MFC2);			//устанавливаем поток РРГ2 = au_MFC2
			au_prev_MFC2=au_MFC2;							//обновляем переменную "предыдущее значение потока"
			q_napusk_start.stt=STOP;						//деактивируем процесс
			}
		else												//если разница больше чем 200 дискрет
			{
			vsp_long=au_prev_MFC2+200;						
			Set5024(&vsp_long,slot_au,B_au_MFC2);			//то повышаем поток на 200 дискрет
			au_prev_MFC2=au_prev_MFC2+200;					//обновляем переменную "предыдущее значение потока"
			}
		}
}
//-------------------------------- Процедура процесса отправки символов через COM-порт -------------------
void otpravka_symvolov(void)
{
	int i,j;
	
	if (Shd_enable_flag < 6)								//Если первая отправка символов
	{
		if (Shd_enable_flag==5) {							//Если 4 обращение к процедуре (0: <LM> 1: DS> 2: FS> 3: - 4: <LM>)
			com_tx('E');
			com_tx('N');
                        com_tx('>');
			Shd_enable_flag++;
			return;
		}
		Shd_enable_flag++;
	}
	
	if (smb_to_send==0)										//если больше нечего отправлять
		{
		q_com_tx.stt=STOP;									//деактивируем прцоесс отправки
		R_Quants=R_Quants & mask_off[8];					//записываем 0 в 8 бит регистра состояния процессов (отправка символов)
		}
	else													//иначе
		{
		i=0;
		while (text_to_send[i]!='>')						//отправляем символы вплоть до символа > (конец команды)
			{
			com_tx(text_to_send[i]);
			i++;
			}
		com_tx(text_to_send[i]);							//отправляем сам символ >
		smb_to_send=smb_to_send-(i+1);						//уменьшаем кол-во символов которые еще нужно отправить
		for (j=0;j<smb_to_send;j++)
			text_to_send[j]=text_to_send[i+1+j];			//перезаписываем оставшиеся символы в начало строки
		}
}
//-------------------------------- Процедура процесса переключения сигнала на вход reset контроллера ШД ------------
void SMC_reset(void)
{
	du_off(slot_du,B_du_SMC_reset);							//переключаем сигнал в низкий уровень напряжения по прошествии 1 сек.
	q_SMC_reset.stt=STOP;									//гарантируя срабатывание оптопары и проч. транзисторов, деактивируем процесс
}	

//=============================== Основная программа =====================================================

void main(void)
{
	int i;
	int server_error;
	char shd_current_disable[10]="<LM>DS>FS>",
	
	dispetcher = ACTIV;     							//Активируем диспетчер задач
	queue = DONUT;										//Последовательность обслуживания процессов - по очереди
	for (i=0;i<31;i++) Share_Mem[i]=0;					//Обнулили память обмена
	
//------------------------------- Инициализация модулей ПЛК ----------------------------------------------	
	v_mask=0;                                   		//0000 0000 0000 0000
	Set5050(&v_mask,slot_du,0,AWord); 					//Установили низкий уровень на каналы ДУ

	Init5017H(slot_ac);									//инициализировали модуль 5017Н АК ПЛК
    High_Speed();       								//перевели модуль АК в режим быстрого счета показаний

	Init5024(slot_au,0,0,0,0); 							//инициализировали модуль 5024 АУ ПЛК
														//и установили нулевые значения

//------------------------------- Инициализация COM-портов -----------------------------------------------														
	if (com_install(1)==1)							//если ошибка инициализации порта 1
		err_code=err_code | mask_on[5]; 			//записываем 1 в 5 бит регистра ошибок "ошибка инициализации"
	else err_code=err_code & mask_off[5]; 			//иначе записываем 0 в 5 бит регистра ошибок
	com_set_speed(57600L);							//устанавливаем скорость обмена, бод
	com_flush_rx();									//очистка буфера приема
	com_flush_tx();									//очистка буфера передачи
	com_set_format(8,2,1);							//формат (длина данных,четность:0-нет/1-нечет/2-чет,стоп бит 1/2) 
	com_raise_dtr();								//устанавливаем высокий уровень сигнала DTR
	com_raise_rts(0x3F8);   						//Устанавливаем высокий уровень сигнала RTS значение однозн. для ком 1

//------------------------------- Инициализация таймеров ПЛК ---------------------------------------------
	if (Timer_Init()==1)								//если ошибка инициализации
		err_code=err_code | mask_on[4]; 				//записываем 1 в 4 бит регистра ошибок.
	else err_code=err_code & mask_off[4]; 				//иначе записываем 0 в 4 бит регисра ошибок.
	
														//Присваиваем таймер процессу откачки
	q_vacuum_start.tm=Timer_Set(1000);  				//Присваиваем индекс таймера, установленного на 1000 мс
	q_vacuum_start.stt=STOP;							//Остановливаем обслуживание процесса
	Timer_Reset(q_vacuum_start.tm);						//Перезапускаем этот таймер

	q_vacuum_stop.tm=Timer_Set(1000);					//Присваиваем таймер процессу остановки откачки
	q_vacuum_stop.stt=STOP;
	Timer_Reset(q_vacuum_stop.tm);

	q_produv_start.tm=Timer_Set(1000);  				//Присваиваем таймер процессу продува газовой линии
	q_produv_start.stt=STOP;
	Timer_Reset(q_produv_start.tm);

	q_napusk_start.tm=Timer_Set(1000);					//Присваиваем таймер процессу постепенного увеличения
	q_napusk_start.stt=STOP;							//потока газонатекания через РРГ
	Timer_Reset(q_napusk_start.tm);

	q_com_tx.tm=Timer_Set(200);							//Присваиваем таймер процессу отправки символов 
	q_com_tx.stt=STOP;									//через COM-порт. Устанавливаем на 200 мс.
	Timer_Reset(q_com_tx.tm);
	
	q_SMC_reset.tm=Timer_Set(1000);						//Присваиваем таймер процессу переключения сигнала
	q_SMC_reset.stt=STOP;								//сброс контроллера ШД
	Timer_Reset(q_SMC_reset.tm);
	
														//Сообщение об успещной инициализации в эмулятор терминала
	adv_printf("Timers have been initialized, starting Server...\n");
	
//------------------------------- Cоздание сервера TCP ---------------------------------------------------
											
	server_error=ADAMTCP_ModServer_Create(502, 200, 2, (unsigned char *)Share_Mem, sizeof(Share_Mem));
											
														//присваиваем локальной переменной код ошибки инициализации
														//параметры: (№ порта, time-out[мс], кол-во клиентов, память обмена)
													
	adv_printf("error code is %d\n", server_error);		//Сообщение с кодом ошибки в эмулятор терминала
	adv_printf("Server started, wait for connect...\n");

	do													//Ожидаем
	{}
	while(ADAMTCP_ModServer_Update() != 1); 			//пока не произойдет первое обращение клиента
	
	adv_printf("First contact has been approached, running dispetcher...\n");
	
//------------------------------- Инициируем выключение обмоток двигателя  -------------------------------

	R_Quants=R_Quants | mask_on[8];					//записываем 1 в 8 бит регистра состояния процессов (отправка символов)
	q_com_tx.stt=START;								//активируем процесс отправки символов через COM-порт
	pattern_writer(0,10,shd_current_disable);		//записываем в буфер 10 символов <LM>DS>FS> с нулевого
	smb_to_send=10;									//записываем в переменную итоговую длину буфера
	
	
//------------------------------- Запускаем диспетчер процессов ------------------------------------------
	DISP:
//------------------------------- Интерпроцесс -----------------------------------------------------------	
		if (ADAMTCP_ModServer_Update())					//Если было обращение клиента и в регистр цикла
		if (Share_Mem[20] != 0)							//было записано значение (был цикл записи у клиента),
			server_update(); 							//то обновляем сервер (сейчас у клиента цикл чтения)
														
//------------------------------- Синхропроцессы в порядке приоритетности --------------------------------
		if (q_vacuum_start.stt==START)           		//Если запущен процесс откачки
		if (tmArriveCnt[q_vacuum_start.tm]!=0)			//И сработал таймер процесса 
			{
			vacuum_start();								//обслуживаем процесс откачки
			Timer_Reset(q_vacuum_start.tm); 			//перезапускаем таймер процесса
			if (queue==PRIORY) goto DISP;				//возвращаемся в начало списка, если
			}											//последовательность обслуживания приоритетная

		if (q_vacuum_stop.stt==START)            		//Процесс остановки откачки
		if (tmArriveCnt[q_vacuum_stop.tm]!=0)
			{
			vacuum_stop();
			Timer_Reset(q_vacuum_stop.tm);
			if (queue==PRIORY) goto DISP;				
			}
	
		if (q_produv_start.stt==START)           		//Процесс продува газовой линии
		if (tmArriveCnt[q_produv_start.tm]!=0)
			{
			produv_start();
			Timer_Reset(q_produv_start.tm);
			if (queue==PRIORY) goto DISP;
			}
		
		if (q_napusk_start.stt==START)          		//Процесс увеличения потока газа через РРГ
		if (tmArriveCnt[q_napusk_start.tm]!=0)
			{
			napusk_start();
			Timer_Reset(q_napusk_start.tm);
			if (queue==PRIORY) goto DISP;
			}
		
	    if (q_com_tx.stt==START)						//Процесс отправки символов через COM-порт
		if (tmArriveCnt[q_com_tx.tm]!=0)
			{
			otpravka_symvolov();
			Timer_Reset(q_com_tx.tm);
			if (queue==PRIORY) goto DISP;
			}
			
		if (q_SMC_reset.stt==START)						//Процесс переключения сигнала сброс контроллера ШД
		if (tmArriveCnt[q_SMC_reset.tm]!=0)
			{
			SMC_reset();
			Timer_Reset(q_SMC_reset.tm);
			if (queue==PRIORY) goto DISP;
			}
		
		if (dispetcher==ACTIV) goto DISP;				//возвращаемся в начало или выходим из диспетчера
														//и завершаем работу

	ADAMTCP_ModServer_Release();						//завершение работы сервера TCP
	com_deinstall();									//завершение работы COM-порта
	Release_All();										//завершение работы программы
}	